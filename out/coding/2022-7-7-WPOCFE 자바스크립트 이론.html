<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Github Blog | Coding</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a309366faaf5640d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a309366faaf5640d.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fd82975a6094609f.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-551bef8982a15171.js" defer=""></script><script src="/_next/static/chunks/pages/_app-67d25757e67bd6f1.js" defer=""></script><script src="/_next/static/chunks/966-f73553dab6aa6822.js" defer=""></script><script src="/_next/static/chunks/pages/coding/%5Bslug%5D-7ebbc302f0094246.js" defer=""></script><script src="/_next/static/fvaCNHH-Pv8PZ0Xa9wfPN/_buildManifest.js" defer=""></script><script src="/_next/static/fvaCNHH-Pv8PZ0Xa9wfPN/_ssgManifest.js" defer=""></script><script src="/_next/static/fvaCNHH-Pv8PZ0Xa9wfPN/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="text-gray-700"><header class="border-b text-2xl font-medium"><nav class="w-ful container mx-auto h-full"><ul class="flex w-full justify-end gap-8"><li class="flex border-b border-transparent hover:border-sky-300 "><a href="/">처음화면</a></li><li class="flex border-b border-transparent hover:border-sky-300 "><a href="/intro">주인이력</a></li><li class="flex border-b border-transparent hover:border-sky-300 border-sky-500"><a href="/coding">코딩공부</a></li></ul></nav></header><main class="container mx-auto h-full"><section class="mx-auto flex h-full min-h-screen justify-between"><aside class=""><div class="h-full"></div></aside><article class="w-full max-w-2xl text-gray-500"><div class="mb-2 flex justify-end space-x-4 text-xs"><span>발행: <!-- -->2022/07/07<!-- --></span><span>수정: <!-- -->2022/07/07<!-- --></span></div><ul class="mb-6 flex list-none justify-end gap-6"><li class="list-none">#<!-- -->원티드 프리온보드 프론트엔드 코스<!-- --></li><li class="list-none">#<!-- -->자바스크립트 이론<!-- --></li></ul><h1 class="mb-5 border-b text-3xl font-semibold">원티드 프리온보드 코스, 이론 자습</h1><p class="markdown-container "><h1 id="1-학습목표">1. 학습목표</h1>
<ol>
<li><code>식별자</code>가 선언되는 과정을 설명할 수 있다.</li>
<li><code>호이스팅</code>에 대해 상세히 설명할 수 있다.</li>
<li><code>표현식</code>과 <code>문</code>의 차이에 대해 설명할 수 있다.</li>
<li><code>값의 전달</code>과 <code>참조의 전달</code>의 차이를 설명할 수 있다.</li>
</ol>
<h2 id="1a-학습">1.A. 학습</h2>
<h3 id="1a1-변수">1.A.1. 변수</h3>
<pre><code class="hljs language-js"><span class="hljs-comment">// 1+2는 아무 곳에도 저장되지 않고, 재사용도 불가능.</span>
<span class="hljs-number">1</span> + <span class="hljs-number">2</span>;

<span class="hljs-comment">// 변수 : 한 개의 값을 저장하기 위한 수단</span>
<span class="hljs-comment">// 변수명 : 메모리 공간에 저장된 값(변수)을 식별할 수 있는 고유한 이름</span>
<span class="hljs-keyword">const</span> id = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;king&quot;</span>;

<span class="hljs-comment">// 객체나 배열 같은 자료구조는 여러개의 값을 그룹화 해 사용할 수 있다.</span>
<span class="hljs-keyword">const</span> list = [
  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;king&quot;</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;왕&quot;</span> },
];

<span class="hljs-comment">// result는 변수명이다.</span>
<span class="hljs-comment">// result에 저장된 값(3)을 변수 값이라 한다.</span>
<span class="hljs-comment">// 변수에 값을 저장하는 것들 할당, 읽어들이는 걸 참조라 한다</span>
<span class="hljs-keyword">const</span> result = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;

<span class="hljs-comment">// var, let은 변수 재할당 가능</span>
<span class="hljs-comment">// 하지만 새로운 메모리 공간에 할당한다</span>
<span class="hljs-keyword">let</span> 색깔 = <span class="hljs-string">&quot;red&quot;</span>;
색깔 = <span class="hljs-string">&quot;black&quot;</span>;

<span class="hljs-comment">// const(constant, 상수)는 변수 재할당 불가능</span>
<span class="hljs-keyword">const</span> 상수 = <span class="hljs-string">&quot;sky&quot;</span>;
상수 = <span class="hljs-string">&quot;blue&quot;</span>; <span class="hljs-comment">// TypeError: invalid assignment to const &#x27;상수&#x27;</span>

<span class="hljs-comment">// 상수가 객체인 경우 내부 값은 변경 가능</span>
<span class="hljs-keyword">const</span> 객체 = {
  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;king&quot;</span>,
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(객체.<span class="hljs-property">id</span>); <span class="hljs-comment">// 1</span>
객체.<span class="hljs-property">id</span> = <span class="hljs-number">2</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(객체.<span class="hljs-property">id</span>); <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// 배열도 가능</span>
<span class="hljs-keyword">const</span> 배열 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(배열); <span class="hljs-comment">// [1, 2, 3]</span>
배열[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(배열); <span class="hljs-comment">// [5, 2, 3]</span>
</code></pre>
<h3 id="1a2-식별자">1.A.2. 식별자</h3>
<ul>
<li>어떤 값을 구별해서 식별할 수 있는 고유한 이름.</li>
<li>식별자 result는 값(3)이 저장돼 있는 메모리 주소를 기억한다.</li>
<li>식별자는 메모리 주소와 매핑 관계다.</li>
<li>매핑 정보는 메모리에 저장되어야 한다.</li>
<li>식별자는 값이 아니라 메모리 주소를 기억하낟.</li>
<li>변수, 함수, 클래스 등의 <strong>이름은 모두 식별자</strong>다.</li>
</ul>
<h3 id="1a3-호이스팅">1.A.3. 호이스팅</h3>
<p>자바스크립트는 코드가 순차적으로 실행되는 런타임시점과 그 이전 시점이 있다.</p>
<p>런타임 전 단계에서 함수와 변수의 호이스팅이 발생하고 식별자를 생성하는데 변수, 함수 호이스팅은 차이점이 있다. <code>var(let, const)</code>로 할당된 <code>변수의 호이스팅</code>은 <code>undefined</code>로 초기화되고, <code>함수 선언문</code>으로 생성된 식별자는 <code>함수 객체</code>로 초기화되기 때문에 런타임에서 선언문 이전에 변수를 참조하면 <code>undefined</code>로 평가되지만 함수 선언문으로 정의한 함수는 선언문 이전에 호출해도 원래 작동을 한다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(함수선언문(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(함수표현식(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// TypeError: 함수표현식 is not a function</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(변수선언문); <span class="hljs-comment">// undefined</span>

<span class="hljs-keyword">const</span> 변수선언문 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 변수 선언문</span>
<span class="hljs-keyword">function</span> 함수선언문(x, y) {
  <span class="hljs-keyword">return</span> x + y;
}
<span class="hljs-keyword">const</span> 함수표현식 = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> x + y;
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(변수선언문); <span class="hljs-comment">// 1</span>
</code></pre>
<h3 id="1a4-가비지-콜렉터">1.A.4. 가비지 콜렉터</h3>
<ul>
<li>자바스크립트는 매니지드 언어로 가비지 콜렉터가 있다(vs 언매니지드 언어))</li>
<li>가비지 콜렉터는 앱이 할당된 메모리를 주기적으로 검사 해 사용하지 않는 메모리를 해제한다.</li>
<li>메모리에서 언제 해제될지는 예측할 수 없다.</li>
<li>사용하지 않는 메모리란 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다.</li>
</ul>
<h3 id="1a5-식별자-이름짓기-규칙">1.A.5. 식별자 이름짓기 규칙</h3>
<ul>
<li>특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.</li>
<li>단, 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다.</li>
<li>숫자로 시작하는 것은 허용하지 않는다.</li>
<li>예약어는 식별자로 사용할 수 없다(ex. new, const, await, if ...)</li>
</ul>
<h3 id="1a6-이름짓기-규칙">1.A.6. 이름짓기 규칙</h3>
<ul>
<li><strong>카멜 케이스</strong> : <code>camelCase</code></li>
<li><strong>스네이크 케이스</strong> : <code>snake_case</code></li>
<li><strong>파스칼 케이스</strong> : <code>PascalCase</code></li>
<li><strong>헝가리언 케이스</strong> :<ul>
<li><code>strFirstName</code>; type + identifier</li>
<li><code>$elem</code> = document.getElementById(&quot;id&quot;); DOM Node</li>
<li><code>observable$</code> = fromEvent(document, &quot;click&quot;); RxJS 옵저버블</li>
</ul>
</li>
</ul>
<h3 id="1a7-표현식과-문">1.A.7. 표현식과 문</h3>
<p>-<strong>값</strong> : 식이 평가되어 생성된 결과</p>
<pre><code class="hljs language-js"><span class="hljs-number">10</span> + <span class="hljs-number">20</span>; <span class="hljs-comment">// 30</span>
</code></pre>
<ul>
<li><strong>리터럴</strong> : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-number">3</span>;
</code></pre>
<ul>
<li><strong>표현식</strong> : <strong>값으로 평가 될 수 있는 문</strong>이다. 평가되면 새로운 값을 생성하거나 기존 값을 참조한다</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> score = <span class="hljs-number">100</span>; <span class="hljs-comment">// 숫자 100은 그 자체로 리터럴</span>
<span class="hljs-keyword">let</span> score = <span class="hljs-number">50</span> + <span class="hljs-number">50</span>; <span class="hljs-comment">// 50 + 50은 평가되어 숫자 값 100을 생성하므로 표현식</span>
score; <span class="hljs-comment">// 변수참조 : 값으로 평가되므로 표현식이다</span>

<span class="hljs-comment">// 값으로 평가 될 수 있는 문은 모두 표현식</span>
<span class="hljs-comment">// 리터럴 표현식</span>
<span class="hljs-number">10</span>;
(<span class="hljs-string">&quot;hello&quot;</span>);

<span class="hljs-comment">// 식별자 표현식</span>
sum;
person.<span class="hljs-property">name</span>;
arr[<span class="hljs-number">1</span>];

<span class="hljs-comment">// 연산자 표현식</span>
<span class="hljs-number">10</span> + <span class="hljs-number">20</span>;
sum = <span class="hljs-number">10</span>;
sum !== <span class="hljs-number">10</span>;

<span class="hljs-comment">// 함수/메서드 호출 표현식(선언 했다고 가정)</span>
<span class="hljs-title function_">square</span>();
person.<span class="hljs-title function_">getName</span>();
</code></pre>
<ul>
<li><strong>문</strong> : 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 변수 선언문</span>
<span class="hljs-keyword">var</span> x;

<span class="hljs-comment">// 할당문</span>
x = <span class="hljs-number">5</span>;

<span class="hljs-comment">// 함수 선언문</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {}

<span class="hljs-comment">// 조건문</span>
<span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}

<span class="hljs-comment">// 반복문</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);
}
</code></pre>
<ul>
<li>표현식인 문과 표현식이 아닌 문</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아님</span>
<span class="hljs-keyword">let</span> x;

<span class="hljs-comment">// 표현식</span>
<span class="hljs-number">1</span>;
<span class="hljs-number">2</span>;
<span class="hljs-number">1</span> + <span class="hljs-number">2</span>;
x = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;

<span class="hljs-comment">// 간단 명료한 구별법, 변수에 할당해보기</span>
<span class="hljs-comment">// 표현식이 아닌 문은 값처럼 사용할 수 없다.</span>
<span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">let</span> x; <span class="hljs-comment">// SyntaxError: Unexpected token var</span>

<span class="hljs-comment">// 할당문은 표현식인 문이기 때문에 값처럼 사용할 수 있다.</span>
<span class="hljs-keyword">let</span> foo = x = <span class="hljs-number">100</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo) <span class="hljs-comment">// 100</span>
</code></pre>
<h3 id="1a8-값의-전달과-참조의-전달">1.A.8. 값의 전달과 참조의 전달</h3>
<h1 id="참고자료">참고자료</h1>
<ul>
<li>강의 자료</li>
<li>모던 자바스크립트 Deep Dive</li>
</ul>
</p></article><aside class=""><div class="h-full"></div></aside></section></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontMatter":{"title":"원티드 프리온보드 코스, 이론 자습","description":"식별자가 선언되는 과정. 호이스팅. 표현식과 문의 차이. 값의 전달과 참조의 전달의 차이.","tags":["원티드 프리온보드 프론트엔드 코스","자바스크립트 이론"],"publishedDate":"2022/07/07","lastModifiedAt":"2022/07/07"},"markdownBody":"\n# 1. 학습목표\n\n1. `식별자`가 선언되는 과정을 설명할 수 있다.\n2. `호이스팅`에 대해 상세히 설명할 수 있다.\n3. `표현식`과 `문`의 차이에 대해 설명할 수 있다.\n4. `값의 전달`과 `참조의 전달`의 차이를 설명할 수 있다.\n\n## 1.A. 학습\n\n### 1.A.1. 변수\n\n```js\n// 1+2는 아무 곳에도 저장되지 않고, 재사용도 불가능.\n1 + 2;\n\n// 변수 : 한 개의 값을 저장하기 위한 수단\n// 변수명 : 메모리 공간에 저장된 값(변수)을 식별할 수 있는 고유한 이름\nconst id = 1;\nconst name = \"king\";\n\n// 객체나 배열 같은 자료구조는 여러개의 값을 그룹화 해 사용할 수 있다.\nconst list = [\n  { id: 1, name: \"king\" },\n  { id: 2, name: \"왕\" },\n];\n\n// result는 변수명이다.\n// result에 저장된 값(3)을 변수 값이라 한다.\n// 변수에 값을 저장하는 것들 할당, 읽어들이는 걸 참조라 한다\nconst result = 1 + 2;\n\n// var, let은 변수 재할당 가능\n// 하지만 새로운 메모리 공간에 할당한다\nlet 색깔 = \"red\";\n색깔 = \"black\";\n\n// const(constant, 상수)는 변수 재할당 불가능\nconst 상수 = \"sky\";\n상수 = \"blue\"; // TypeError: invalid assignment to const '상수'\n\n// 상수가 객체인 경우 내부 값은 변경 가능\nconst 객체 = {\n  id: 1,\n  name: \"king\",\n};\nconsole.log(객체.id); // 1\n객체.id = 2;\nconsole.log(객체.id); // 2\n\n// 배열도 가능\nconst 배열 = [1, 2, 3];\nconsole.log(배열); // [1, 2, 3]\n배열[0] = 5;\nconsole.log(배열); // [5, 2, 3]\n```\n\n### 1.A.2. 식별자\n\n- 어떤 값을 구별해서 식별할 수 있는 고유한 이름.\n- 식별자 result는 값(3)이 저장돼 있는 메모리 주소를 기억한다.\n- 식별자는 메모리 주소와 매핑 관계다.\n- 매핑 정보는 메모리에 저장되어야 한다.\n- 식별자는 값이 아니라 메모리 주소를 기억하낟.\n- 변수, 함수, 클래스 등의 **이름은 모두 식별자**다.\n\n### 1.A.3. 호이스팅\n\n자바스크립트는 코드가 순차적으로 실행되는 런타임시점과 그 이전 시점이 있다.\n\n런타임 전 단계에서 함수와 변수의 호이스팅이 발생하고 식별자를 생성하는데 변수, 함수 호이스팅은 차이점이 있다. `var(let, const)`로 할당된 `변수의 호이스팅`은 `undefined`로 초기화되고, `함수 선언문`으로 생성된 식별자는 `함수 객체`로 초기화되기 때문에 런타임에서 선언문 이전에 변수를 참조하면 `undefined`로 평가되지만 함수 선언문으로 정의한 함수는 선언문 이전에 호출해도 원래 작동을 한다.\n\n```js\nconsole.log(함수선언문(1, 2)); // 3\nconsole.log(함수표현식(1, 2)); // TypeError: 함수표현식 is not a function\nconsole.log(변수선언문); // undefined\n\nconst 변수선언문 = 1; // 변수 선언문\nfunction 함수선언문(x, y) {\n  return x + y;\n}\nconst 함수표현식 = function (x, y) {\n  return x + y;\n};\n\nconsole.log(변수선언문); // 1\n```\n\n### 1.A.4. 가비지 콜렉터\n\n- 자바스크립트는 매니지드 언어로 가비지 콜렉터가 있다(vs 언매니지드 언어))\n- 가비지 콜렉터는 앱이 할당된 메모리를 주기적으로 검사 해 사용하지 않는 메모리를 해제한다.\n- 메모리에서 언제 해제될지는 예측할 수 없다.\n- 사용하지 않는 메모리란 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다.\n\n### 1.A.5. 식별자 이름짓기 규칙\n\n- 특수문자를 제외한 문자, 숫자, 언더스코어(\\_), 달러 기호($)를 포함할 수 있다.\n- 단, 특수문자를 제외한 문자, 언더스코어(\\_), 달러 기호($)로 시작해야 한다.\n- 숫자로 시작하는 것은 허용하지 않는다.\n- 예약어는 식별자로 사용할 수 없다(ex. new, const, await, if ...)\n\n### 1.A.6. 이름짓기 규칙\n\n- **카멜 케이스** : `camelCase`\n- **스네이크 케이스** : `snake_case`\n- **파스칼 케이스** : `PascalCase`\n- **헝가리언 케이스** :\n  - `strFirstName`; type + identifier\n  - `$elem` = document.getElementById(\"id\"); DOM Node\n  - `observable$` = fromEvent(document, \"click\"); RxJS 옵저버블\n\n### 1.A.7. 표현식과 문\n\n-**값** : 식이 평가되어 생성된 결과\n\n```js\n10 + 20; // 30\n```\n\n- **리터럴** : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법\n\n```js\n3;\n```\n\n- **표현식** : **값으로 평가 될 수 있는 문**이다. 평가되면 새로운 값을 생성하거나 기존 값을 참조한다\n\n```js\nlet score = 100; // 숫자 100은 그 자체로 리터럴\nlet score = 50 + 50; // 50 + 50은 평가되어 숫자 값 100을 생성하므로 표현식\nscore; // 변수참조 : 값으로 평가되므로 표현식이다\n\n// 값으로 평가 될 수 있는 문은 모두 표현식\n// 리터럴 표현식\n10;\n(\"hello\");\n\n// 식별자 표현식\nsum;\nperson.name;\narr[1];\n\n// 연산자 표현식\n10 + 20;\nsum = 10;\nsum !== 10;\n\n// 함수/메서드 호출 표현식(선언 했다고 가정)\nsquare();\nperson.getName();\n```\n\n- **문** : 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.\n\n```js\n// 변수 선언문\nvar x;\n\n// 할당문\nx = 5;\n\n// 함수 선언문\nfunction foo() {}\n\n// 조건문\nif (x \u003e 1) {\n  console.log(x);\n}\n\n// 반복문\nfor (var i = 0; i \u003c 2; i++) {\n  console.log(i);\n}\n```\n\n- 표현식인 문과 표현식이 아닌 문\n\n```js\n// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아님\nlet x;\n\n// 표현식\n1;\n2;\n1 + 2;\nx = 1 + 2;\n\n// 간단 명료한 구별법, 변수에 할당해보기\n// 표현식이 아닌 문은 값처럼 사용할 수 없다.\nlet foo = let x; // SyntaxError: Unexpected token var\n\n// 할당문은 표현식인 문이기 때문에 값처럼 사용할 수 있다.\nlet foo = x = 100;\nconsole.log(foo) // 100\n```\n\n### 1.A.8. 값의 전달과 참조의 전달\n\n# 참고자료\n\n- 강의 자료\n- 모던 자바스크립트 Deep Dive\n"},"__N_SSG":true},"page":"/coding/[slug]","query":{"slug":"2022-7-7-WPOCFE 자바스크립트 이론"},"buildId":"fvaCNHH-Pv8PZ0Xa9wfPN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>